= Customize Cypher

In some cases, you may need to write highly customized queries within the Cypher Builder. For instance if you:

* Need to embed existing Cypher queries
* Need to use Cypher Builder within a larger Cypher query
* Need to use features that are not supported in the current version of the Cypher Builder
* Use custom functions or procedures


[WARNING]
====
Embedding custom Cypher in a query may lead to security issues such as Code Injection and must be done with care.  
====

== Custom Variable Names

Usually, Cypher Builder takes care of Variable names, ensuring that names do not collide. In some cases, you may need to set custom names, to do it, you can use the `Named*` variables:

```javascript
new Cypher.NamedVariable("myVarName")
```

To learn more, check xref:variables-and-params.adoc#_named_variables[Named Variables].

=== Build Prefix

Whilst not recommended, maybe you may need to mix multiple queries built with Cypher builder into a single string.

For example:

```js
const match1=new Cypher.Match(new Cypher.Node({ labels: ["Movie"] }))
const match2=new Cypher.Match(new Cypher.Node({ labels: ["Person"] }))

const cypher=`
${match1.build()}
${match2.build()}
`
```

Will generate the following Cypher:

```cypher
MATCH(this0:Movie)
MATCH(this0:Person)
```

As you can see, `this0` is used for both `MATCH` statements, despite the variables being different. This is caused by both queries (`match1` and `match2`) being built separately.

If merging these queries before executing `build` (i.e. using `Cypher.concat`) is not a viable solution, a `prefix` string can be passed to `.build()` to avoid name collision:

```js
const cypher=`
${match1.build("movie")}
${match2.build("person")}
`
```

In this case, the resulting Cypher will look like:

```cypher
MATCH(movie_this0:Movie)
MATCH(person_this0:Person)
```

Note that named variables will not be affected by the prefix.

== Custom Parameters

Parameters (i.e. `new Cypher.Param`) are only generated if they are used in the query. To add custom parameters, regardless of them being used or not, these can be passed as a second parameter to `.build`:

```js
const clause = new Cypher.Return(new Cypher.Param("Hello"))
clause.build("", {
    myParameter: "Hello World"
});
```

This generates the Cypher:

```cypher
RETURN $param1
```

And the parameters:

```json
{
    "param1": "Hello",
    "myParameter": "Hello World"
}
```

== Custom Function & Procedures

=== Functions

=== Procedures

== Raw Cypher

The class `Cypher.RawCypher` allows embedding a Cypher string within a larger query built with Cypher Builder, acting as a wildcard that can be used anywhere.

For instance:

```js
const customReturn = new Cypher.RawCypher(`10 as myVal`);

const returnClause = new Cypher.Return(customReturn);

const { cypher, params } = returnClause.build();
```

This will return the following Cypher:

```cypher
RETURN 10 as myVal
```

In this case, the `RETURN` clause is being generated by Cypher Builder, but the actual value `10 as myVal` has been injected with `RawCypher`. This string can be anything, including other clauses or invalid Cypher, and can be generated dynamically:

```js
const returnVar="myVal"
const customReturn = new Cypher.RawCypher(`10 as ${returnVar}`);

const returnClause = new Cypher.Return(customReturn);
```

`RawCypher` can be used in `Cypher.concat` to attach an arbitrary string to any Cypher Builder element. 

=== Using a callback

In more complex scenarios, you may need to access variables created with the Cypher Builder in your custom Cypher string, however, these values are not available before executing `.build`. To achieve this, `RawCypher` supports a callback that will be executed when the query is being built, and have access to the variables. 

This callback receives a parameter `env` that can be used to manually compile Cypher Builder clauses and translate variable names. The callback can return the following values:

* `string`: Returns the Cypher string to be used for this element.
* `[string, object]`: Returns a tuple, with the first element being the cypher string, and the second an object with the parameters to be injected in the query.
* `undefined`: If undefined, the RawCypher will be translated as an empty string.


In this example, a `MATCH...RETURN` statement is being created with the Cypher Builder in the usual way, however, a custom `RawCypher` is being injected as part of the `WHERE` subclause.  

```js
const movie = new Cypher.Node({ labels: ["Movie"] });
const match = new Cypher.Match(movie)
    .where(
        new Cypher.RawCypher((env) => {
            const movieStr = Cypher.utils.compileCypher(movie, env);

            const cypher = `${movieStr}.prop = $myParam`;
            const params = {
                myParam: "Hello World",
            };

            return [cypher, params];
        })
    )
    .return(movie);

const { cypher, params } = match.build();
```

This returns the following Cypher:

```cypher
MATCH (this0:`Movie`)
WHERE this0.prop = $myParam
RETURN this0
```

And the following parameters:

```json
{
    "myParam": "Hello World"
}
```

The callback passed into the RawCypher is producing the string `this0.prop = $myParam`. To achieve this, it uses the utility method `utils.compileCypher`, passing the variable `movie` and the `env` parameter. This returns the string `this0`. Finally, the custom parameter `$myParam` is being returned in the tuple `[cypher, params]`, ensuring that it will be available when executing `match.build()`. 
