= Variables and parameters

This section how to effectively use variables and parameters with the Cypher Builder and how to avoid common pitfalls.

== Variables
Variables can be used in Cypher to reference parts of a pattern and hold values.
For example:

```Cypher
MATCH (m:Movie)
RETURN m
```

Here, the variable `m` refers to a node matched in the pattern `(:Movie)` that is returned afterward.

One of the biggest challenges of writing dynamic Cypher queries is that the resulting variables in the query need to have unique names that correctly reference the values. To achieve this Cypher Builder provides an abstraction of variables in the form of JavaScript references, eliminating the need to track variable names.

=== Types

Cypher builder distinguishes three types of variables:

* `Node`: Holds a reference to a Node matched in a pattern.
* `Relationship`: Holds a reference to a Relationship in a pattern.
* `Variable`: Generic variable reference.
* `Path`: A variable to hold a path.

All variables are just virtual references to a Cypher variable that, when the code is generated, will be translated to a unique name.


=== Defining a variable

An arbitrary variable can be defined with:

```javascript
const myVar = new Cypher.Variable();
```

This variable can then be used as an expression in any clause that supports variables, for instance:

```javascript
const myVar = new Cypher.Variable();
const query = new Cypher.Return(myVar)
```

```cypher
RETURN var0
```

The name `var0` is automatically generated when `.build()` is called to prevent. If the same variable is reused, the same name will be created, for instance:

```javascript
const myVar = new Cypher.Variable();
const query = new Cypher.With(myVar).return(myVar);
```

```cypher
WITH var0
RETURN var0
```

You can create different variables if needed, each instance will be associated with a different name:

```javascript
const withVar = new Cypher.Variable();
const returnVar = new Cypher.Variable();
const query = new Cypher.With(withVar).return(returnVar);
```

```cypher
WITH var0
RETURN var1
```

=== Nodes and relationships

Nodes and relationships are variables holding some extra data regarding nodes and relationships to be used in xref:patterns.adoc[Patterns].
For example:

```javascript
const movie = new Cypher.Node({labels: ["Movie"]});
const relationship = new Cypher.Relationship({type: "ACTED_IN"});
const match = new Cypher.Match(new Cypher.Pattern(movie).related(relationship).to()).return(movie);
```

```Cypher
MATCH (this0:Movie)-[this1:ACTED_IN]->(this2)
RETURN this0
```

In this example, the node variable `movie` is created and then used in the `MATCH` and `RETURN` clauses.

In the translated Cypher, you can see how the node variable is translated to the Cypher variable `this0`, while the relationship is assigned to `this1`. These names are not defined in your JavaScript code, but are automatically generated when the query is built with `.build()`. The labels and type passed to these variables are used in the Pattern.

The following parameters can be passed to Node:
* `labels`: An array containing the labels of that node.

The following parameters can be passed to a Relationship:
* `type`: A string with the type of the relationship


==== Escaping labels and types

Labels and types will be automatically escaped if any uncommon character is detected. For example:

```javascript
const movie = new Cypher.Node({labels: ["My Movie"]});
const match = new Cypher.Match(movie).return(movie);
```

```Cypher
MATCH (this0:`My Movie`)
RETURN this0
```

Note how `My Movie` is being surrounded in quotes to prevent any form of Cypher injection with dynamic labels.

=== Named Variables

By default, variables do not have a name and a unique name will be generated at build time to avoid collisions. However, in some cases you may want to generate a query with a specific name. To do this, all variable types have a counterpart _named_ class:

* `NamedVariable`
* `NamedNode`
* `NamedRelationship`

These can be used in the same fashion as normal variables, but a name must be provided when creating them:

```javascript
const movie = new Cypher.NamedNode("n", {labels: ["Movie"]});
const match = new Cypher.Match(movie).return(movie);
```

```Cypher
MATCH (n:Movie)
RETURN n
```


=== Path
Path variables can be used for path assignment in patterns, for example:

```cypher
MATCH p0 = (this1)-[this2:ACTED_IN]->(this3)
RETURN p0
```

To assign a path variable, use the method `.assignToPath` in the relevant clauses and pass a `new Path()` instance:

```javascript
const path = new Cypher.Path();

const query = new Cypher.Match(pattern).assignToPath(path).return(path);
```

=== Property
Variables such as nodes or maps may contain properties. To access these properties in the generated Cypher, the method `.property` can be used on variables:

```javascript
const movie = new Cypher.Node({labels: ["Movie"]})
const query = new Cypher.Match(movie).return(movie.property("title"));
```

```cypher
MATCH(this0:Movie)
RETURN this0.title
```

==== Nested properties
Nested properties can also be accessed, either by passing multiple parameters or concatenating calls to `.property`:

```javascript
new Cypher.Variable().property("movie", "title");
new Cypher.Variable().property("movie").property("title")
```

In both cases, the resulting Cypher will look like:

```cypher
var0.movie.title
```

==== Using expressions
Expressions can also be used as a property key, to dynamically access properties:

```javascript
const movie = new Cypher.Node({labels: ["Movie"]})
const query = new Cypher.Match(movie).return(movie.property(Cypher.plus(new Cypher.Param("ti"), new Cypher.Literal("tle"))));
```

This will automatically use square brackets `[]` notation to safely execute the expression:

```cypher
MATCH(this0:Movie)
RETURN this0[($param0 + $param1)]
```

==== Index
Like properties, an index can also be accessed through the method `.index`:

```javascript
new Cypher.Variable().index(2);
```

```cypher
var0[2]
```


== Parameters
Parameters can be created by using the class `Param`. Parameters behave similarly to variables, however, they contain a defined value, that will automatically be returned as part of the parameters when the `.build()` method is called.

For example:

```javascript
const movie = new Cypher.Node({ labels: ["Movie"] });
const titleProp = movie.property(movie);

const query = new Cypher.Match(movie).where(Cypher.eq(titleProp, new Cypher.Param("The Matrix")));

const {cypher, params} = query.build();
```

Returns the following Cypher:

```cypher
MATCH (this0:Movie)
WHERE this0[this0] = $param0
```

And the following parameters object:

```js
{
    param0: "The Matrix"
}
```

Parameters can also be reused, like variables:

```javascript
const movie = new Cypher.Node({ labels: ["Movie"] });
const titleProp = movie.property(movie);
const titleParam = new Cypher.Param("The Matrix")

const query = new Cypher.Match(movie).where(Cypher.eq(titleProp, titleParam)).return(titleParam);

const {cypher, params} = query.build();
```

_Cypher_
```cypher
MATCH (this0:Movie)
WHERE this0[this0] = $param0
RETURN this0, $param0
```

_Params_
```js
{
    param0: "The Matrix"
}
```


== Literal
Literal values can be defined with `Cypher.Literal`. Literals behave like Parameters, but it will inject the value provided directly into the Cypher, serializing it as needed.

For instance:

```javascript
const movie = new Cypher.Node({ labels: ["Movie"] });
const titleProp = movie.property(movie);
const titleLiteral = new Cypher.Literal("The Matrix")

const query = new Cypher.Match(movie).where(Cypher.eq(titleProp, titleParam)).return(titleParam);

const {cypher, params} = query.build();
```

_Cypher_
```cypher
MATCH (this0:Movie)
WHERE this0[this0] = "The Matrix"
RETURN this0, "The Matrix"
```

_Params_
```js
{ }
```

Note how the value `The Matrix` is not injected directly, but correctly serialized to a string in Cypher. The following values are supported by `Literal`:

* String: `Cypher.Literal("Hello")` -> `"Hello"`
* Number: `Cypher.Literal(5)` -> `5`
* Boolean: `Cypher.Literal(true)` -> `true`
* Array: `Cypher.Literal([5, "Hello"])` -> `[5, "Hello"]`
* Null: `Cypher.Literal(null)` -> `NULL`


[NOTE]
====
Note that Literal does not escape the values and code injection is a risk. It is generally recommended to use `Cypher.Param` instead.
====

=== NULL

As a shortcut for `new Cypher.Literal(null)`, the constant `Cypher.Null` is available. This will be translated to `NULL`.


== `WITH` and aliasing

Â¿?


== Environment
