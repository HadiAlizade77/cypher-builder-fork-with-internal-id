[[lists]]
:description: This page shows how to use Cypher lists.
= Lists

Cypher lists can be created with `Cypher.List`, passing an array of Cypher expressions, for example:

[source, javascript]
----
new Cypher.Return(new Cypher.List([new Cypher.Literal(1), new Cypher.Literal(2)]));
----

[source, cypher]
----
RETURN [1, 2]
----

More complex expressions as part of the list are also possible:

[source, javascript]
----
new Cypher.List([Cypher.labels(node)]));
----

[source, cypher]
----
RETURN [labels(node)]
----


[NOTE]
====
`Cypher.Literal` is a more succinct way of creating simple, literal lists: `new Cypher.Literal(["element 1", "element 2"])`
====



== Index
With the method `.index` of a variable, you can create index access for lists:


[source, javascript]
----
myVariable.index(2)
----

[source, cypher]
----
var0[2]
----


== List Comprehension

link:https://neo4j.com/docs/cypher-manual/current/values-and-types/lists/#cypher-list-comprehension[List Comprehensions] can be created with `new Cypher.ListComprehension` and passing a variable to be used in the comprehension. You also need an expression resulting in the original list to create a new list from:


[source, javascript]
----
const listComprehension = new Cypher.ListComprehension(variable, new Cypher.Literal([1,2]))
----

[source, cypher]
----
[var0 IN [1,2]]
----

Alternatively, the original list expression can be passed with the method `.in`:

[source, javascript]
----
const listComprehension = new Cypher.ListComprehension(variable).in(new Cypher.Literal([1,2]))
----

Using the methods `where` and `map` you can construct the filter and mapping parts of the comprehension:


[source, javascript]
----
const listComprehension = new Cypher.ListComprehension(variable)
    .in(exprVariable)
    .where(andExpr)
    .map(Cypher.plus(variable, new Cypher.Literal(1)));
----

[source, cypher]
----
[var0 IN $param1 WHERE var0 = $param0 | (var0 + 1)]
----

== Pattern Comprehension

link:https://neo4j.com/docs/cypher-manual/current/values-and-types/lists/#cypher-pattern-comprehension[Pattern Comprehensions] are created with `new Cypher.PatternComprehension`, passing a xref:../patterns.adoc#patterns[pattern] and a map expression if needed:



[source, javascript]
----
const movie = new Cypher.Node({ labels: ["Movie"] });
const rel = new Cypher.Relationship({
    type: "ACTED_IN",
});
const actor=new Cypher.Node({labels: ["Actor"]})

const pattern = new Cypher.Pattern(movie).related(re).to(actor)


const comprehension = new Cypher.PatternComprehension(pattern, actor.property("name"));
----

[source, cypher]
----
[(this0:Movie)-[:ACTED_IN]->(this1:Actor) | this1.name]
----


Filters can be added with the `.where` method:

[source, javascript]
----
const movie = new Cypher.Node({ labels: ["Movie"] });
const rel = new Cypher.Relationship({
    type: "ACTED_IN",
});
const actor = new Cypher.Node({ labels: ["Actor"] });

const pattern = new Cypher.Pattern(movie).related(rel).to(actor);

const comprehension = new Cypher.PatternComprehension(pattern, actor.property("name")).where(
    Cypher.contains(movie.property("title"), new Cypher.Literal("Matrix"))
);
----

[source, cypher]
----
[(this0:Movie)-[this2:ACTED_IN]->(this1:Actor) WHERE this0.title CONTAINS "Matrix" | this1.name]"
----
